!function(e,t){(e.indexedDB=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB||window.shimIndexedDB)&&(e.IDBTransaction=window.IDBTransaction||window.webkitIDBTransaction||window.msIDBTransaction),"object"==typeof exports&&"undefined"!=typeof module?module.exports=t:"function"==typeof define&&define.amd?define(t):e.dbIndexed=t}(this,function(e){e=e||"indexedDB";var t,n,i={},r=[];async function o(o,a){const s=indexedDB.open(e,n);s.addEventListener("upgradeneeded",e=>(async function(e){r.forEach(t=>{if(!e.objectStoreNames.contains(t)){let n={},r=i[t].split(",");r.includes("++id")&&(n={keyPath:"id",autoIncrement:!0});let o=e.createObjectStore(t,n);r.filter(e=>!e.includes("id")).forEach(e=>{let t=e.replace(/\&/g,"");o.createIndex(t,t,{unique:e.includes("&")})})}})})(e.target.result)),s.addEventListener("success",e=>{t=e.target.result;let n=s.result;n.onversionchange=function(){n.close()},o(t)}),s.addEventListener("error",e=>{a(e)})}async function a(){return new Promise((e,n)=>{t?e(t):o(e,n)})}return{version:function(e){return n=10*e,t=null,this},stores:async function(e){return new Promise(async(t,n)=>{i={...i,...e},r=Object.keys(i);for(let e=0;e<r.length;e++){let t=r[e];this[t]={getAll:()=>new Promise(async(e,n)=>{let i=await a();var r=[],o=i.transaction([t],"readonly").objectStore(t);o.mozGetAll?o.mozGetAll().onsuccess=function(t){e(t.target.result)}:o.openCursor().onsuccess=function(t){var n=t.target.result;n?(r.push(n.value),n.continue()):e(r)}}),get:e=>new Promise(async(n,i)=>{var r=(await a()).transaction([t],"readonly").objectStore(t).get(e);r.onerror=i,r.onsuccess=function(){n(r.result)}}),add:e=>new Promise(async(n,i)=>{let r=(await a()).transaction([t],"readwrite").objectStore(t).add(e);r.onerror=function(e){i(e.target)},r.onsuccess=function(){n({...e,id:r.result})}}),delete:async e=>new Promise(async(n,i)=>{let r=(await a()).transaction([t],"readwrite").objectStore(t);var o=await r.get(e),s=r.delete(e);s.onerror=i,s.onsuccess=(()=>n(o.result))}),put:async e=>new Promise(async(n,i)=>{let r=(await a()).transaction([t],"readwrite").objectStore(t);if(e.id){var o=r.put(e);o.onerror=i,o.onsuccess=function(){n({...e,id:o.result})}}else i("Object without id, can't update.")}),bulkAdd:async e=>new Promise(async(n,i)=>{let r=(await a()).transaction([t],"readwrite").objectStore(t);var o=e.map(e=>new Promise((t,n)=>{var i=r.add(e);i.onerror=n,i.onsuccess=function(){t({...e,id:i.result})}}));Promise.all(o).then(n).catch(i)}),clear:async()=>new Promise(async(e,n)=>{let i=(await a()).transaction([t],"readwrite").objectStore(t).clear();i.onerror=function(){e(!1)},i.onsuccess=function(t){e(!0)}}),where:function(e){if(void 0===e)throw new Error('Missing "key" to search...');return"object"==typeof e?new Promise(async(t,n)=>{t((await this.getAll()).filter(function(t){for(var n in e)if(void 0===t[n]||t[n]!=e[n])return!1;return!0}))}):"string"==typeof e?{equal:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>n[e]===t))}),notEqual:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>n[e]!==t))}),contains:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>n[e].includes(t)))}),notContains:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>!n[e].includes(t)))}),above:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>n[e]>t))}),aboveEqual:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>n[e]>=t))}),below:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>n[e]<t))}),belowEqual:t=>new Promise(async(n,i)=>{n((await this.getAll()).filter(n=>n[e]<=t))})}:void 0}}}await a(),t(this)})}}});
